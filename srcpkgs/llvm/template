# Template file for 'llvm'
pkgname=llvm
version=2.9
distfiles="
http://www.llvm.org/releases/${version}/llvm-${version}.tgz
http://www.llvm.org/releases/${version}/clang-${version}.tgz"
build_style=gnu_configure
configure_args="--disable-expensive-checks --disable-debug-runtime
--enable-targets=all --enable-bindings=none --enable-optimize
--enable-shared --enable-libffi --enable-llvmc-dynamic"
short_desc="Low Level Virtual Machine"
maintainer="Juan RP <xtraeme@gmail.com>"
checksum="
661236cfa17428b48cfa9cbb9909f7569c64b8ecd219fd91dbc00e3b557b3779
70c41f3f782a71cbaa7bc8d6ea29fce4263ad3e8558dfecc6dc11cdef17909df"

long_desc="
 Low Level Virtual Machine (LLVM) is:

 1. A compilation strategy designed to enable effective program optimization
    across the entire lifetime of a program. LLVM supports effective
    optimization at compile time, link-time (particularly interprocedural),
    run-time and offline (i.e., after software is installed), while remaining
    transparent to developers and maintaining compatibility with existing
    build scripts.

 2. A virtual instruction set - LLVM is a low-level object code
    representation that uses simple RISC-like instructions, but provides
    rich, language-independent, type information and dataflow (SSA)
    information about operands. This combination enables sophisticated
    transformations on object code, while remaining light-weight enough to
    be attached to the executable. This combination is key to allowing
    link-time, run-time, and offline transformations.

 3. A compiler infrastructure - LLVM is also a collection of source code that
    implements the language and compilation strategy. The primary components
    of the LLVM infrastructure are a GCC-based C &amp; C++ front-end, a
    link-time optimization framework with a growing set of global and
    interprocedural analyses and transformations, static back-ends for many
    popular (and some obscure) architectures, a back-end which emits portable
    C code, and a Just-In-Time compilers for several architectures.

 4. LLVM does not imply things that you would expect from a high-level
    virtual machine. It does not require garbage collection or run-time code
    generation (In fact, LLVM makes a great static compiler!). Note that
    optional LLVM components can be used to build high-level virtual machines
    and other systems that need these services."

subpackages="libclang clang-analyzer clang clang-devel libllvm"
subpackages="${subpackages} llvm-devel llvm-docs"

# XXX: Investigate bindings support.
Add_dependency run libgcc
Add_dependency run glibc
Add_dependency run libstdc++
Add_dependency run libffi
Add_dependency run libclang
Add_dependency run libllvm
Add_dependency build groff
Add_dependency build perl
Add_dependency build python
Add_dependency build libffi-devel

pre_configure()
{
	# Move clang files into the llvm source.
	if [ -d ${XBPS_BUILDDIR}/clang-${version} ]; then
		mv ${XBPS_BUILDDIR}/clang-${version} ${wrksrc}/tools/clang
	fi
}

pre_install()
{
	# for pod2html
	export PATH=$PATH:/usr/lib/perl5/core_perl/bin
}
