From 2146e21a6190016af2e36b829665ff958f3799f3 Mon Sep 17 00:00:00 2001
From: Juan RP <xtraeme@gmail.com>
Date: Wed, 2 Jan 2013 17:21:50 +0100
Subject: [PATCH 1/2] Remove NetBSD specific code, ifdefs, etc. We only care
 about userspace.

---
 include/rbtree.h       |   5 --
 src/prop_array.c       |  12 +---
 src/prop_data.c        |   3 -
 src/prop_dictionary.c  |  15 ++---
 src/prop_number.c      |  22 ++-----
 src/prop_object.c      |   2 +-
 src/prop_object_impl.h | 167 -------------------------------------------------
 src/prop_rb_impl.h     | 108 --------------------------------
 src/prop_string.c      |   2 -
 src/rb.c               |  20 ------
 10 files changed, 11 insertions(+), 345 deletions(-)

diff --git a/include/rbtree.h b/include/rbtree.h
index b32307d..3c9c9e2 100644
--- include/rbtree.h
+++ include/rbtree.h
@@ -32,13 +32,8 @@
 #ifndef _SYS_RBTREE_H_
 #define	_SYS_RBTREE_H_
 
-#if defined(_KERNEL) || defined(_STANDALONE)
-#include <sys/types.h>
-
-#else
 #include <stdbool.h>
 #include <inttypes.h>
-#endif
 #include <queue.h>
 
 #if __GNUC_PREREQ(2, 96)
diff --git a/src/prop_array.c b/src/prop_array.c
index 8c7c94f..565418b 100644
--- src/prop_array.c
+++ src/prop_array.c
@@ -31,11 +31,7 @@
 
 #include <prop/prop_array.h>
 #include "prop_object_impl.h"
-
-#if !defined(_KERNEL) && !defined(_STANDALONE)
 #include <errno.h>
-#define __unused	/* empty */
-#endif
 
 struct _prop_array {
 	struct _prop_object	pa_obj;
@@ -51,8 +47,6 @@ struct _prop_array {
 #define PA_F_IMMUTABLE		0x01	/* array is immutable */
 
 _PROP_POOL_INIT(_prop_array_pool, sizeof(struct _prop_array), "proparay")
-_PROP_MALLOC_DEFINE(M_PROP_ARRAY, "prop array",
-		    "property array container object")
 
 static _prop_object_free_rv_t
 		_prop_array_free(prop_stack_t, prop_object_t *);
@@ -341,7 +335,7 @@ static prop_object_t
 _prop_array_iterator_next_object(void *v)
 {
 	struct _prop_array_iterator *pai = v;
-	prop_array_t pa __unused = pai->pai_base.pi_obj;
+	prop_array_t pa = pai->pai_base.pi_obj;
 	prop_object_t po;
 
 	_PROP_ASSERT(prop_object_is_array(pa));
@@ -368,7 +362,7 @@ static void
 _prop_array_iterator_reset(void *v)
 {
 	struct _prop_array_iterator *pai = v;
-	prop_array_t pa __unused = pai->pai_base.pi_obj;
+	prop_array_t pa = pai->pai_base.pi_obj;
 
 	_PROP_ASSERT(prop_object_is_array(pa));
 
@@ -866,7 +860,6 @@ prop_array_internalize(const char *xml)
 	return _prop_generic_internalize(xml, "array");
 }
 
-#if !defined(_KERNEL) && !defined(_STANDALONE)
 /*
  * prop_array_externalize_to_file --
  *	Externalize an array to the specified file.
@@ -909,4 +902,3 @@ prop_array_internalize_from_file(const char *fname)
 
 	return (array);
 }
-#endif /* _KERNEL && !_STANDALONE */
diff --git a/src/prop_data.c b/src/prop_data.c
index da07fd2..abb7b18 100644
--- src/prop_data.c
+++ src/prop_data.c
@@ -52,9 +52,6 @@ struct _prop_data {
 
 _PROP_POOL_INIT(_prop_data_pool, sizeof(struct _prop_data), "propdata")
 
-_PROP_MALLOC_DEFINE(M_PROP_DATA, "prop data",
-		    "property data container object")
-
 static _prop_object_free_rv_t
 		_prop_data_free(prop_stack_t, prop_object_t *);
 static bool	_prop_data_externalize(
diff --git a/src/prop_dictionary.c b/src/prop_dictionary.c
index 4c21fcb..8b329fb 100644
--- src/prop_dictionary.c
+++ src/prop_dictionary.c
@@ -35,10 +35,7 @@
 #include "prop_object_impl.h"
 #include "prop_rb_impl.h"
 
-#if !defined(_KERNEL) && !defined(_STANDALONE)
 #include <errno.h>
-#define __unused	/* empty */
-#endif
 
 /*
  * We implement these like arrays, but we keep them sorted by key.
@@ -98,8 +95,6 @@ struct _prop_dictionary {
 
 _PROP_POOL_INIT(_prop_dictionary_pool, sizeof(struct _prop_dictionary),
 		"propdict")
-_PROP_MALLOC_DEFINE(M_PROP_DICT, "prop dictionary",
-		    "property dictionary container object")
 
 static _prop_object_free_rv_t
 		_prop_dictionary_free(prop_stack_t, prop_object_t *);
@@ -174,7 +169,7 @@ struct _prop_dictionary_iterator {
 
 static int
 /*ARGSUSED*/
-_prop_dict_keysym_rb_compare_nodes(void *ctx __unused,
+_prop_dict_keysym_rb_compare_nodes(void *ctx,
 				   const void *n1, const void *n2)
 {
 	const struct _prop_dictionary_keysym *pdk1 = n1;
@@ -185,7 +180,7 @@ _prop_dict_keysym_rb_compare_nodes(void *ctx __unused,
 
 static int
 /*ARGSUSED*/
-_prop_dict_keysym_rb_compare_key(void *ctx __unused,
+_prop_dict_keysym_rb_compare_key(void *ctx,
 				 const void *n, const void *v)
 {
 	const struct _prop_dictionary_keysym *pdk = n;
@@ -629,7 +624,7 @@ static prop_object_t
 _prop_dictionary_iterator_next_object(void *v)
 {
 	struct _prop_dictionary_iterator *pdi = v;
-	prop_dictionary_t pd __unused = pdi->pdi_base.pi_obj;
+	prop_dictionary_t pd = pdi->pdi_base.pi_obj;
 	prop_dictionary_keysym_t pdk;
 
 	_PROP_ASSERT(prop_object_is_dictionary(pd));
@@ -656,7 +651,7 @@ static void
 _prop_dictionary_iterator_reset(void *v)
 {
 	struct _prop_dictionary_iterator *pdi = v;
-	prop_dictionary_t pd __unused = pdi->pdi_base.pi_obj;
+	prop_dictionary_t pd = pdi->pdi_base.pi_obj;
 
 	_PROP_RWLOCK_RDLOCK(pd->pd_rwlock);
 	_prop_dictionary_iterator_reset_locked(pdi);
@@ -1375,7 +1370,6 @@ prop_dictionary_internalize(const char *xml)
 	return _prop_generic_internalize(xml, "dict");
 }
 
-#if !defined(_KERNEL) && !defined(_STANDALONE)
 /*
  * prop_dictionary_externalize_to_file --
  *	Externalize a dictionary to the specified file.
@@ -1419,4 +1413,3 @@ prop_dictionary_internalize_from_file(const char *fname)
 
 	return (dict);
 }
-#endif /* !_KERNEL && !_STANDALONE */
diff --git a/src/prop_number.c b/src/prop_number.c
index dfd5e42..ab3013a 100644
--- src/prop_number.c
+++ src/prop_number.c
@@ -33,16 +33,8 @@
 #include "prop_object_impl.h"
 #include "prop_rb_impl.h"
 
-#if defined(_KERNEL)
-#include <sys/systm.h>
-#elif defined(_STANDALONE)
-#include <sys/param.h>
-#include <lib/libkern/libkern.h>
-#else
 #include <errno.h>
 #include <stdlib.h>
-#define __unused	/* empty */
-#endif
 
 struct _prop_number {
 	struct _prop_object	pn_obj;
@@ -120,7 +112,7 @@ _prop_number_compare_values(const struct _prop_number_value *pnv1,
 
 static int
 /*ARGSUSED*/
-_prop_number_rb_compare_nodes(void *ctx __unused,
+_prop_number_rb_compare_nodes(void *ctx,
 			      const void *n1, const void *n2)
 {
 	const struct _prop_number *pn1 = n1;
@@ -131,7 +123,7 @@ _prop_number_rb_compare_nodes(void *ctx __unused,
 
 static int
 /*ARGSUSED*/
-_prop_number_rb_compare_key(void *ctx __unused, const void *n, const void *v)
+_prop_number_rb_compare_key(void *ctx, const void *n, const void *v)
 {
 	const struct _prop_number *pn = n;
 	const struct _prop_number_value *pnv = v;
@@ -512,14 +504,11 @@ _prop_number_internalize_unsigned(struct _prop_object_internalize_context *ctx,
 	_PROP_ASSERT(/*CONSTCOND*/sizeof(unsigned long long) ==
 		     sizeof(uint64_t));
 
-#ifndef _KERNEL
 	errno = 0;
-#endif
 	pnv->pnv_unsigned = (uint64_t) strtoull(ctx->poic_cp, &cp, 0);
-#ifndef _KERNEL		/* XXX can't check for ERANGE in the kernel */
 	if (pnv->pnv_unsigned == UINT64_MAX && errno == ERANGE)
 		return (false);
-#endif
+
 	pnv->pnv_is_unsigned = true;
 	ctx->poic_cp = cp;
 
@@ -534,15 +523,12 @@ _prop_number_internalize_signed(struct _prop_object_internalize_context *ctx,
 
 	_PROP_ASSERT(/*CONSTCOND*/sizeof(long long) == sizeof(int64_t));
 
-#ifndef _KERNEL
 	errno = 0;
-#endif
 	pnv->pnv_signed = (int64_t) strtoll(ctx->poic_cp, &cp, 0);
-#ifndef _KERNEL		/* XXX can't check for ERANGE in the kernel */
 	if ((pnv->pnv_signed == INT64_MAX || pnv->pnv_signed == INT64_MIN) &&
 	    errno == ERANGE)
 	    	return (false);
-#endif
+
 	pnv->pnv_is_unsigned = false;
 	ctx->poic_cp = cp;
 
diff --git a/src/prop_object.c b/src/prop_object.c
index 087110c..ec76453 100644
--- src/prop_object.c
+++ src/prop_object.c
@@ -61,7 +61,7 @@ _prop_object_init(struct _prop_object *po, const struct _prop_object_type *pot)
  */
 /*ARGSUSED*/
 void
-_prop_object_fini(struct _prop_object *po _PROP_ARG_UNUSED)
+_prop_object_fini(struct _prop_object *po)
 {
 	/* Nothing to do, currently. */
 }
diff --git a/src/prop_object_impl.h b/src/prop_object_impl.h
index 6251709..65b1739 100644
--- src/prop_object_impl.h
+++ src/prop_object_impl.h
@@ -32,12 +32,7 @@
 #ifndef _PROPLIB_PROP_OBJECT_IMPL_H_
 #define	_PROPLIB_PROP_OBJECT_IMPL_H_
 
-#if defined(_KERNEL) || defined(_STANDALONE)
-#include <lib/libkern/libkern.h>
-#else
 #include <inttypes.h>
-#endif
-
 #include "prop_stack.h"
 
 struct _prop_object_externalize_context {
@@ -147,7 +142,6 @@ struct _prop_object_internalize_context *
 void		_prop_object_internalize_context_free(
 				struct _prop_object_internalize_context *);
 
-#if !defined(_KERNEL) && !defined(_STANDALONE)
 bool		_prop_object_externalize_write_file(const char *,
 						    const char *, size_t, bool);
 
@@ -160,7 +154,6 @@ struct _prop_object_internalize_mapped_file *
 		_prop_object_internalize_map_file(const char *);
 void		_prop_object_internalize_unmap_file(
 				struct _prop_object_internalize_mapped_file *);
-#endif /* !_KERNEL && !_STANDALONE */
 
 typedef bool (*prop_object_internalizer_t)(prop_stack_t, prop_object_t *,
 				struct _prop_object_internalize_context *);
@@ -231,110 +224,6 @@ struct _prop_object_iterator {
 	uint32_t	pi_version;
 };
 
-#define _PROP_NOTHREAD_ONCE_DECL(x)	static bool x = false;
-#define _PROP_NOTHREAD_ONCE_RUN(x,f)					\
-	do {								\
-		if ((x) == false) {					\
-			f();						\
-			x = true;					\
-		}							\
-	} while (/*CONSTCOND*/0)
-
-#if defined(_KERNEL)
-
-/*
- * proplib in the kernel...
- */
-
-#include <sys/param.h>
-#include <sys/malloc.h>
-#include <sys/pool.h>
-#include <sys/systm.h>
-#include <sys/rwlock.h>
-#include <sys/once.h>
-
-#define	_PROP_ASSERT(x)			KASSERT(x)
-
-#define	_PROP_MALLOC(s, t)		malloc((s), (t), M_WAITOK)
-#define	_PROP_CALLOC(s, t)		malloc((s), (t), M_WAITOK | M_ZERO)
-#define	_PROP_REALLOC(v, s, t)		realloc((v), (s), (t), M_WAITOK)
-#define	_PROP_FREE(v, t)		free((v), (t))
-
-#define	_PROP_POOL_GET(p)		pool_get(&(p), PR_WAITOK)
-#define	_PROP_POOL_PUT(p, v)		pool_put(&(p), (v))
-
-struct prop_pool_init {
-	struct pool *pp;
-	size_t size;
-	const char *wchan;
-};
-#define	_PROP_POOL_INIT(pp, size, wchan)				\
-struct pool pp;								\
-static const struct prop_pool_init _link_ ## pp[1] = {			\
-	{ &pp, size, wchan }						\
-};									\
-__link_set_add_rodata(prop_linkpools, _link_ ## pp);
-
-#define	_PROP_MALLOC_DEFINE(t, s, l)					\
-		MALLOC_DEFINE(t, s, l);
-
-#define	_PROP_MUTEX_DECL_STATIC(x)	static kmutex_t x;
-#define	_PROP_MUTEX_INIT(x)		mutex_init(&(x),MUTEX_DEFAULT,IPL_NONE)
-#define	_PROP_MUTEX_LOCK(x)		mutex_enter(&(x))
-#define	_PROP_MUTEX_UNLOCK(x)		mutex_exit(&(x))
-
-#define	_PROP_RWLOCK_DECL(x)		krwlock_t x ;
-#define	_PROP_RWLOCK_INIT(x)		rw_init(&(x))
-#define	_PROP_RWLOCK_RDLOCK(x)		rw_enter(&(x), RW_READER)
-#define	_PROP_RWLOCK_WRLOCK(x)		rw_enter(&(x), RW_WRITER)
-#define	_PROP_RWLOCK_UNLOCK(x)		rw_exit(&(x))
-#define	_PROP_RWLOCK_DESTROY(x)		rw_destroy(&(x))
-
-#define _PROP_ONCE_DECL(x)		static ONCE_DECL(x);
-#define _PROP_ONCE_RUN(x,f)		RUN_ONCE(&(x), f)
-
-#elif defined(_STANDALONE)
-
-/*
- * proplib in a standalone environment...
- */
-
-#include <lib/libsa/stand.h>
-
-void *		_prop_standalone_calloc(size_t);
-void *		_prop_standalone_realloc(void *, size_t);
-
-#define	_PROP_ASSERT(x)			/* nothing */
-
-#define	_PROP_MALLOC(s, t)		alloc((s))
-#define	_PROP_CALLOC(s, t)		_prop_standalone_calloc((s))
-#define	_PROP_REALLOC(v, s, t)		_prop_standalone_realloc((v), (s))
-#define	_PROP_FREE(v, t)		dealloc((v), 0)		/* XXX */
-
-#define	_PROP_POOL_GET(p)		alloc((p))
-#define	_PROP_POOL_PUT(p, v)		dealloc((v), (p))
-
-#define	_PROP_POOL_INIT(p, s, d)	static const size_t p = s;
-
-#define	_PROP_MALLOC_DEFINE(t, s, l)	/* nothing */
-
-#define	_PROP_MUTEX_DECL_STATIC(x)	/* nothing */
-#define	_PROP_MUTEX_INIT(x)		/* nothing */
-#define	_PROP_MUTEX_LOCK(x)		/* nothing */
-#define	_PROP_MUTEX_UNLOCK(x)		/* nothing */
-
-#define	_PROP_RWLOCK_DECL(x)		/* nothing */
-#define	_PROP_RWLOCK_INIT(x)		/* nothing */
-#define	_PROP_RWLOCK_RDLOCK(x)		/* nothing */
-#define	_PROP_RWLOCK_WRLOCK(x)		/* nothing */
-#define	_PROP_RWLOCK_UNLOCK(x)		/* nothing */
-#define	_PROP_RWLOCK_DESTROY(x)		/* nothing */
-
-#define _PROP_ONCE_DECL(x)		_PROP_NOTHREAD_ONCE_DECL(x)
-#define _PROP_ONCE_RUN(x,f)		_PROP_NOTHREAD_ONCE_RUN(x,f)
-
-#else
-
 /*
  * proplib in user space...
  */
@@ -357,49 +246,6 @@ void *		_prop_standalone_realloc(void *, size_t);
 
 #define	_PROP_POOL_INIT(p, s, d)	static const size_t p = s;
 
-#define	_PROP_MALLOC_DEFINE(t, s, l)	/* nothing */
-
-#if defined(__NetBSD__) && defined(_LIBPROP)
-/*
- * Use the same mechanism as libc; we get pthread mutexes for threaded
- * programs and do-nothing stubs for non-threaded programs.
- */
-#include "reentrant.h"
-#define	_PROP_MUTEX_DECL_STATIC(x)	static mutex_t x;
-#define	_PROP_MUTEX_INIT(x)		mutex_init(&(x), NULL)
-#define	_PROP_MUTEX_LOCK(x)		mutex_lock(&(x))
-#define	_PROP_MUTEX_UNLOCK(x)		mutex_unlock(&(x))
-
-#define	_PROP_RWLOCK_DECL(x)		rwlock_t x ;
-#define	_PROP_RWLOCK_INIT(x)		rwlock_init(&(x), NULL)
-#define	_PROP_RWLOCK_RDLOCK(x)		rwlock_rdlock(&(x))
-#define	_PROP_RWLOCK_WRLOCK(x)		rwlock_wrlock(&(x))
-#define	_PROP_RWLOCK_UNLOCK(x)		rwlock_unlock(&(x))
-#define	_PROP_RWLOCK_DESTROY(x)		rwlock_destroy(&(x))
-
-#define _PROP_ONCE_DECL(x)						\
-	static pthread_once_t x = PTHREAD_ONCE_INIT;
-#define _PROP_ONCE_RUN(x,f)		thr_once(&(x), (void(*)(void))f);
-
-#elif defined(HAVE_NBTOOL_CONFIG_H)
-/*
- * None of NetBSD's build tools are multi-threaded.
- */
-#define	_PROP_MUTEX_DECL_STATIC(x)	/* nothing */
-#define	_PROP_MUTEX_INIT(x)		/* nothing */
-#define	_PROP_MUTEX_LOCK(x)		/* nothing */
-#define	_PROP_MUTEX_UNLOCK(x)		/* nothing */
-
-#define	_PROP_RWLOCK_DECL(x)		/* nothing */
-#define	_PROP_RWLOCK_INIT(x)		/* nothing */
-#define	_PROP_RWLOCK_RDLOCK(x)		/* nothing */
-#define	_PROP_RWLOCK_WRLOCK(x)		/* nothing */
-#define	_PROP_RWLOCK_UNLOCK(x)		/* nothing */
-#define	_PROP_RWLOCK_DESTROY(x)		/* nothing */
-
-#define _PROP_ONCE_DECL(x)		_PROP_NOTHREAD_ONCE_DECL(x)
-#define _PROP_ONCE_RUN(x,f)		_PROP_NOTHREAD_ONCE_RUN(x,f)
-#else
 /*
  * Use pthread mutexes everywhere else.
  */
@@ -419,18 +265,5 @@ void *		_prop_standalone_realloc(void *, size_t);
 #define _PROP_ONCE_DECL(x)						\
 	static pthread_once_t x = PTHREAD_ONCE_INIT;
 #define _PROP_ONCE_RUN(x,f)		pthread_once(&(x),(void(*)(void))f)
-#endif
-
-#endif /* _KERNEL */
-
-/*
- * Language features.
- */
-#if defined(__NetBSD__)
-#include <sys/cdefs.h>
-#define	_PROP_ARG_UNUSED		__unused
-#else
-#define	_PROP_ARG_UNUSED		/* delete */
-#endif /* __NetBSD__ */
 
 #endif /* _PROPLIB_PROP_OBJECT_IMPL_H_ */
diff --git a/src/prop_rb_impl.h b/src/prop_rb_impl.h
index 8b7e964..54e064a 100644
--- src/prop_rb_impl.h
+++ src/prop_rb_impl.h
@@ -32,7 +32,6 @@
 #ifndef _PROP_RB_IMPL_H_
 #define	_PROP_RB_IMPL_H_
 
-#if 1
 #include <rbtree.h>
 
 /*
@@ -44,111 +43,4 @@
 #define	_prop_rb_tree_remove_node	rb_tree_remove_node
 #define	_prop_rb_tree_iterate		rb_tree_iterate
 
-#else	/* __NetBSD__ */
-
-#include <sys/types.h>
-#include <sys/queue.h>
-#include <machine/endian.h>
-
-struct rb_node {
-	struct rb_node *rb_nodes[3];
-#define	RB_NODE_LEFT		0
-#define	RB_NODE_RIGHT		1
-#define	RB_NODE_OTHER		1
-#define	RB_NODE_PARENT		2
-#define	rb_left		rb_nodes[RB_NODE_LEFT]
-#define	rb_right	rb_nodes[RB_NODE_RIGHT]
-#define	rb_parent	rb_nodes[RB_NODE_PARENT]
-	union {
-		struct {
-#if BYTE_ORDER == LITTLE_ENDIAN
-			unsigned int : 28;
-			unsigned int s_root : 1;
-			unsigned int s_position : 1;
-			unsigned int s_color : 1;
-			unsigned int s_sentinel : 1;
-#endif
-#if BYTE_ORDER == BIG_ENDIAN
-			unsigned int s_sentinel : 1;
-			unsigned int s_color : 1;
-			unsigned int s_position : 1;
-			unsigned int s_root : 1;
-			unsigned int : 28;
-#endif
-		} u_s;
-		unsigned int u_i;
-	} rb_u;
-#define	rb_root				rb_u.u_s.s_root
-#define	rb_position			rb_u.u_s.s_position
-#define	rb_color			rb_u.u_s.s_color
-#define	rb_sentinel			rb_u.u_s.s_sentinel
-#define	rb_properties			rb_u.u_i
-#define	RB_SENTINEL_P(rb)		((rb)->rb_sentinel + 0)
-#define	RB_LEFT_SENTINEL_P(rb)		((rb)->rb_left->rb_sentinel + 0)
-#define	RB_RIGHT_SENTINEL_P(rb)		((rb)->rb_right->rb_sentinel + 0)
-#define	RB_PARENT_SENTINEL_P(rb)	((rb)->rb_parent->rb_sentinel + 0)
-#define	RB_CHILDLESS_P(rb)		(RB_LEFT_SENTINEL_P(rb) \
-					 && RB_RIGHT_SENTINEL_P(rb))
-#define	RB_TWOCHILDREN_P(rb)		(!RB_LEFT_SENTINEL_P(rb) \
-					 && !RB_RIGHT_SENTINEL_P(rb))
-#define	RB_ROOT_P(rb)			((rb)->rb_root != false)
-#define	RB_RED_P(rb)			((rb)->rb_color + 0)
-#define	RB_BLACK_P(rb)			(!(rb)->rb_color)
-#define	RB_MARK_RED(rb)			((void)((rb)->rb_color = 1))
-#define	RB_MARK_BLACK(rb)		((void)((rb)->rb_color = 0))
-#define	RB_MARK_ROOT(rb)		((void)((rb)->rb_root = 1))
-#ifdef RBDEBUG
-	TAILQ_ENTRY(rb_node) rb_link;
-#endif
-};
-
-#ifdef RBDEBUG
-TAILQ_HEAD(rb_node_qh, rb_node);
-
-#define	RB_TAILQ_REMOVE				TAILQ_REMOVE
-#define	RB_TAILQ_INIT				TAILQ_INIT
-#define	RB_TAILQ_INSERT_HEAD(a, b, c)		TAILQ_INSERT_HEAD
-#define	RB_TAILQ_INSERT_BEFORE(a, b, c)		TAILQ_INSERT_BEFORE
-#define	RB_TAILQ_INSERT_AFTER(a, b, c, d)	TAILQ_INSERT_AFTER
-#else
-#define	RB_TAILQ_REMOVE(a, b, c)		do { } while (/*CONSTCOND*/0)
-#define	RB_TAILQ_INIT(a)			do { } while (/*CONSTCOND*/0)
-#define	RB_TAILQ_INSERT_HEAD(a, b, c)		do { } while (/*CONSTCOND*/0)
-#define	RB_TAILQ_INSERT_BEFORE(a, b, c)		do { } while (/*CONSTCOND*/0)
-#define	RB_TAILQ_INSERT_AFTER(a, b, c, d)	do { } while (/*CONSTCOND*/0)
-#endif
-
-typedef int (*rb_compare_nodes_fn)(const struct rb_node *,
-    const struct rb_node *);
-typedef int (*rb_compare_key_fn)(const struct rb_node *, const void *);
-
-struct rb_tree_ops {
-	rb_compare_nodes_fn	rbto_compare_nodes;
-	rb_compare_key_fn	rbto_compare_key;
-};
-
-struct rb_tree {
-	struct rb_node *rbt_root;
-#ifdef RBDEBUG
-	struct rb_node_qh rbt_nodes;
-#endif
-	const struct rb_tree_ops *rbt_ops;
-#ifdef RBDEBUG
-	unsigned int rbt_count;
-#endif
-};
-
-void	_prop_rb_tree_init(struct rb_tree *, const struct rb_tree_ops *);
-bool	_prop_rb_tree_insert_node(struct rb_tree *, struct rb_node *);
-struct rb_node	*
-	_prop_rb_tree_find(struct rb_tree *, const void *);
-void	_prop_rb_tree_remove_node(struct rb_tree *, struct rb_node *);
-#ifdef RBDEBUG
-void	_prop_rb_tree_check(const struct rb_tree *, bool);
-#endif
-struct rb_node *
-	_prop_rb_tree_iterate(struct rb_tree *, struct rb_node *, unsigned int);
-
-#endif /* __NetBSD__ */
-
 #endif	/* _PROP_RB_IMPL_H_*/
diff --git a/src/prop_string.c b/src/prop_string.c
index 4f9ed88..6daddbd 100644
--- src/prop_string.c
+++ src/prop_string.c
@@ -48,8 +48,6 @@ struct _prop_string {
 
 _PROP_POOL_INIT(_prop_string_pool, sizeof(struct _prop_string), "propstng")
 
-_PROP_MALLOC_DEFINE(M_PROP_STRING, "prop string",
-		    "property string container object")
 
 static _prop_object_free_rv_t
 		_prop_string_free(prop_stack_t, prop_object_t *);
diff --git a/src/rb.c b/src/rb.c
index 54d5dff..8be152a 100644
--- src/rb.c
+++ src/rb.c
@@ -29,7 +29,6 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#if !defined(_KERNEL) && !defined(_STANDALONE)
 #include <sys/types.h>
 #include <stddef.h>
 #include <assert.h>
@@ -39,25 +38,6 @@
 #else
 #define KASSERT(s)	do { } while (/*CONSTCOND*/ 0)
 #endif
-#else
-#include <lib/libkern/libkern.h>
-#endif
-
-#ifdef _LIBC
-__weak_alias(rb_tree_init, _rb_tree_init)
-__weak_alias(rb_tree_find_node, _rb_tree_find_node)
-__weak_alias(rb_tree_find_node_geq, _rb_tree_find_node_geq)
-__weak_alias(rb_tree_find_node_leq, _rb_tree_find_node_leq)
-__weak_alias(rb_tree_insert_node, _rb_tree_insert_node)
-__weak_alias(rb_tree_remove_node, _rb_tree_remove_node)
-__weak_alias(rb_tree_iterate, _rb_tree_iterate)
-#ifdef RBDEBUG
-__weak_alias(rb_tree_check, _rb_tree_check)
-__weak_alias(rb_tree_depths, _rb_tree_depths)
-#endif
-
-#include "namespace.h"
-#endif
 
 #ifdef RBTEST
 #include "rbtree.h"
-- 
1.8.1.3

