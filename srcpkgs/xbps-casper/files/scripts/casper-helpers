## Casper helper functions, used by casper on boot.

MP_QUIET="-q"

sys2dev()
{
    sysdev=${1#/sys}
    echo "/dev/$(/sbin/udevadm info -q name -p ${sysdev} 2>/dev/null|| echo ${sysdev##*/})"
}

subdevices()
{
    sysblock=$1
    r=""
    for dev in "${sysblock}" "${sysblock}"/*; do
        if [ -e "${dev}/dev" ]; then
            r="${r} ${dev}"
        fi
    done
    echo ${r}
}

is_supported_fs()
{
    # FIXME: do something better like the scan of supported filesystems
    fstype="${1}"
    case ${fstype} in
        vfat|iso9660|udf|ext2|ext3|ext4|ntfs)
            return 0
            ;;
    esac
    return 1
}

get_fstype()
{
    /sbin/blkid -s TYPE -o value $1 2>/dev/null
}

where_is_mounted()
{
    device=$1
    if grep -q "^$device " /proc/mounts; then
        mountpoint="$(grep "^$device " /proc/mounts | awk '{print $2; exit}')"
        grep "^$device " /proc/mounts | read d mountpoint rest
        echo $mountpoint
        return 0
    fi
    return 1
}

fs_size()
{
    # Returns used/free fs kbytes + 5% more
    # You could pass a block device as $1 or the mount point as $2

    dev="${1}"
    mountp="${2}"
    used="${3}"

    if [ -z "${mountp}" ]; then
        mountp=$(where_is_mounted "${dev}")
        if [ "$?" -gt 0 ]; then
            mountp="/mnt/tmp_fs_size"
            mkdir -p "${mountp}"
            mount -t $(get_fstype "${dev}") -o ro "${dev}" "${mountp}"
            doumount=1
        fi
    fi

    if [ "${used}" = "used" ]; then
        size=$(du -ks ${mountp} | cut -f1)
        size=$(expr ${size} + ${size} / 20 ) # FIXME: 5% more to be sure
    else
        # free space
        size="$(df -k | grep -s ${mountp} | awk '{print $4}')"
    fi

    if [ -n "${doumount}" ]; then
        umount "${mountp}"
        rmdir "${mountp}"
    fi
    echo "${size}"
}

setup_loop() {
    local fspath=$1
    local module=$2
    local pattern=$3
    local offset=$4

    modprobe ${MP_QUIET} -b "$module"
    /sbin/udevadm settle

    if [ "$module" = loop ]; then
        if [ ! -e /dev/loop0 ]; then
            # temporary workaround for kernel bug
            for i in 0 1 2 3 4 5 6 7; do
                mknod "/dev/loop$i" b 7 "$i" || true
            done
        fi

        dev="$(losetup -f)"
        if [ "$dev" ]; then
            if [ -n "$offset" ]; then
                losetup -o "$offset" "$dev" "$fspath"
            else
                losetup "$dev" "$fspath"
            fi
            echo "$dev"
            return 0
        else
            panic "No loop devices available"
        fi
    else
        for loopdev in $pattern; do
            if [ "$(cat $loopdev/size)" -eq 0 ]; then
                dev=$(sys2dev "${loopdev}")
                if [ -n "$offset" ]; then
                    losetup -o "$offset" "$dev" "$fspath"
                else
                    losetup "$dev" "$fspath"
                fi
                echo "$dev"
                return 0
            fi
        done
        panic "No loop devices available"
    fi
}
